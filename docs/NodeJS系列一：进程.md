---
title: NodeJS系列一：进程
date: 2021-8-16
categories: 
layout: Post
tags: 
summary: 
feed:
  enable: true
---

## 进程与线程

进程是应用程序的执行副本，同时也是操作系统分配资源的最小单位。启动应用程序时，操作系统会将应用程序（磁盘）放入进程（内存）。

在这个过程中，操作系统要给进程分配资源，这些资源包括：

- 用户和组（哪个用户、组启动的进程）
- 目录资源
  - 进程的工作目录（看我演示）
  - 进程的可见目录
- 文件资源
  - 设备资源
  - - 网络资源
  - 数据文件
  - 代码文件
  - ……
- 主线程

> 注意：进程不能执行程序！ —— 执行程序的是线程。操作系统会为每个进程分配一个主线程，然后进程还可以分配其他线程。



跟进程相比，线程负责执行程序。你可能会问，进程为什么不同时分配资源与执行程序呢？那时因为进程需要的资源多，线程需要的资源少。线程只需要执行程序相关的资源：程序计数器（执行到哪一行）、栈（存储执行程序的中间结果）、寄存器（辅助计算以及控制）。形象的说，创建进城是秒级的，创建线程是ms级的。



## NodeJS线程模型

NodeJS的进程也是进程，进程下可以有很多线程。所以NodeJS也有很多线程来一起完成执行程序的工作。

- NodeJS进程也有主线程
- NodeJS进程也可以使用多线程（只不过不允许用户用）
- Node.js进程有工作目录
- Node.js进程可以拥有文件资源
- ......

总之，操作系统给进程的，NodeJS进程也都能享受，操作系统不给进程的NodeJS进程也没有。从这个层面看，NodeJS进程，Java进程、Python进程没有本质区别。



NodeJS进程不是单线程，内部有很多线程。用户写的NodeJS程序只在一个线程中执行。



线程的本质是抽象要并发(concurrent)做的事情，比如说：浏览器渲染、用户操作界面、发送网络请求。这3件事情，用3个线程来表达，看上去这3件事情就可以同时被完成，这就是并行的能力。NodeJS每遇到一件需要操作系统支持的事情，就会使用一个单独的线程。比如说：读取文件、发送网络请求、定时器、等等。

为了防止线程太多，Node.js内部有一个线程池，用于处理需要OS支持的行为。

NodeJS这么做的目的是为了实现**并行**，否则会让用户感受到延迟。




## 事件循环-EventLoop

事件循环（EventLoop）是解决**并发**问题的方案。

以下是简化模型，当需要调用并发的能力里，用户程序发送请求给**Event Loop**，接着，**Event Loop**会在线程池中注册回调，在事件执行完成后会触发回调来通知用户程序。如果**Event Loop**上所有注册的任务都处理完了，就会切换回用户程序，如果用户程序没有事情做，那么就结束执行。

![image-20210803021534672](./assets/image-20210803021534672.png)

我们通常将用户程序称为：主栈（Main Stack）上的程序。本质上，消息循环和用户程序在同一个线程中执行，因此也发生在Main Stack上。而定时器，网络请求，数据库操作、文件操作等等行为，则发生在线程池中。



如下所示，正真的NodeJS的**Event Loop**模型会存在优先级的控制，这么做的原因是如果采用朴素的公平性（先到先得）策略会导致定时器更加不稳定。

![image-20210803020741121](./assets/image-20210803020741121.png)



## 总结

Node.js不是一个单线程模型，从设计上它的用户程序和EventLoop在一个线程上执行——因此也在一个CPU核心上执行。因为，一个线程同一时刻只在一个CPU上执行。在Node.js进程被创建到销毁的这段时间，EventLoop将一直存在，因此这个线程会在一个CPU上完成所有的工作。那么，其他线程，比如文件系统访问、网络请求也是在一个CPU上吗？ 当然可以不是，它们可以用线程池技术利用多核的特性。

所以Node.js是单线程吗？ —— 和面试官要说清楚。 你说是不是单线程都可以，毕竟用户程序+EventLoop是在单线程执行的。 但是Node.js进程内部是有多线程模型的，之所以用户程序+EventLoop单线程，是因为在**非计算密集型**（也就是I/O密集型）的工作场景下，这样效率最高。（IO多路复用技术）

另外，setTimeout和setImmediate哪个优先？ ——这不重要。 你在写程序中开始思考这个问题，说明程序写错了。 面试官问，你告诉它这不重要。对程序员来说，它们都是异步，异步就**不要对他们的执行顺序做任何假设**。

管他是宏任务、微任务、callback还是timer，通通异步转同步（promise,yield用起来）。

把更多的时间花在更有价值的思考上，多问自己这几个问题：

- 还认为JS是单线程吗？JS进程内有线程池吗？ 
- 任务的本质是协程（或者线程吗）？是
- 为什么不用多线程设计Node.js？在IO密集型的场景下，Event Loop模型的性能最高
- 异步转同步（yield,async)性能下降吗？ 不会